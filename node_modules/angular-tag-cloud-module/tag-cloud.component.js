"use strict";
var core_1 = require('@angular/core');
var platform_browser_1 = require('@angular/platform-browser');
var TagCloudComponent = (function () {
    function TagCloudComponent(el, renderer, sanitizer) {
        this.el = el;
        this.renderer = renderer;
        this.sanitizer = sanitizer;
        this.width = 500;
        this.height = 300;
        this.removeOverflow = false;
        this.alreadyPlacedWords = [];
    }
    TagCloudComponent.prototype.ngOnInit = function () {
        if (!this.data) {
            console.error('angular-tag-cloud: No data passed. Please pass tags data as json');
            return;
        }
        this.options = {
            step: 2.0,
            aspectRatio: (this.width / this.height),
            width: this.width,
            height: this.height,
            center: {
                x: (this.width / 2.0),
                y: (this.height / 2.0)
            },
            removeOverflow: this.removeOverflow
        };
        this.renderer.setElementStyle(this.el.nativeElement, 'width', this.options.width + 'px');
        this.renderer.setElementStyle(this.el.nativeElement, 'height', this.options.height + 'px');
        this.drawWordCloud();
    };
    TagCloudComponent.prototype.drawWordCloud = function () {
        var _this = this;
        // Sort this.data from the word with the highest weight to the one with the lowest
        this.data.sort(function (a, b) {
            if (a.weight < b.weight) {
                return 1;
            }
            else if (a.weight > b.weight) {
                return -1;
            }
            else {
                return 0;
            }
        });
        this.data.forEach(function (elem, index) {
            _this.drawWord(index, elem);
        });
    };
    // Helper function to test if an element overlaps others
    TagCloudComponent.prototype.hitTest = function (currentEl, otherEl) {
        // Check elements for overlap one by one, stop and return false as soon as an overlap is found
        for (var i = 0; i < otherEl.length; i++) {
            if (this.overlapping(currentEl, otherEl[i])) {
                return true;
            }
        }
        return false;
    };
    // Pairwise overlap detection
    TagCloudComponent.prototype.overlapping = function (a, b) {
        return (Math.abs(2.0 * a.offsetLeft + a.offsetWidth - 2.0 * b.offsetLeft - b.offsetWidth) < a.offsetWidth + b.offsetWidth &&
            Math.abs(2.0 * a.offsetTop + a.offsetHeight - 2.0 * b.offsetTop - b.offsetHeight) < a.offsetHeight + b.offsetHeight)
            ? true : false;
    };
    ;
    // Function to draw a word, by moving it in spiral until it finds a suitable empty place. This will be iterated on each word.
    TagCloudComponent.prototype.drawWord = function (index, word) {
        // Define the ID attribute of the span that will wrap the word
        var angle = 6.28 * Math.random(), radius = 0.0, weight = 5, wordSpan;
        // Check if min(weight) > max(weight) otherwise use default
        if (this.data[0].weight > this.data[this.data.length - 1].weight) {
            // Linearly map the original weight to a discrete scale from 1 to 10
            weight = Math.round((word.weight - this.data[this.data.length - 1].weight) /
                (this.data[0].weight - this.data[this.data.length - 1].weight) * 9.0) + 1;
        }
        // Create a new span and insert node.
        wordSpan = this.renderer.createElement(this.el.nativeElement, 'span');
        wordSpan.className = 'w' + weight;
        var node = this.renderer.createText(this.el.nativeElement, word.text);
        // Append href if there's a link alongwith the tag
        if (word.link !== undefined && word.link !== '') {
            var wordLink = this.renderer.createElement(this.el.nativeElement, 'a');
            wordLink.href = word.link;
            if (word.external !== undefined && word.external) {
                wordLink.target = '_blank';
            }
            wordLink.appendChild(node);
            node = wordLink;
        }
        if (word.color !== undefined && word.color !== '') {
            this.renderer.setElementStyle(node, 'color', word.color);
        }
        wordSpan.appendChild(node);
        var width = wordSpan.offsetWidth, height = wordSpan.offsetHeight, left = this.options.center.x, top = this.options.center.y;
        // Save a reference to the style property, for better performance
        var wordStyle = wordSpan.style;
        wordStyle.position = 'absolute';
        // place the first word
        wordStyle.left = left + 'px';
        wordStyle.top = top + 'px';
        while (this.hitTest(wordSpan, this.alreadyPlacedWords)) {
            radius += this.options.step;
            angle += (index % 2 === 0 ? 1 : -1) * this.options.step;
            left = this.options.center.x - (width / 2.0) + (radius * Math.cos(angle)) * this.options.aspectRatio;
            top = this.options.center.y + radius * Math.sin(angle) - (height / 2.0);
            wordStyle.left = left + 'px';
            wordStyle.top = top + 'px';
        }
        // Don't render word if part of it would be outside the container
        if (this.options.removeOverflow && (left < 0 || top < 0 || (left + width) > this.options.width || (top + height) > this.options.height)) {
            wordSpan.remove();
            return;
        }
        this.alreadyPlacedWords.push(wordSpan);
    };
    ;
    TagCloudComponent.decorators = [
        { type: core_1.Component, args: [{
                    selector: 'angular-tag-cloud',
                    template: '',
                    styles: ["\n    /* fonts */\n    :host {\n      font-family: \"Helvetica\", \"Arial\", sans-serif;\n      font-size: 10px;\n      line-height: normal;\n    }\n    :host /deep/ a:host {\n      font-size: inherit;\n      text-decoration: none;\n    }\n    :host /deep/ span.w10 { font-size: 550%; }\n    :host /deep/ span.w9 { font-size: 500%; }\n    :host /deep/ span.w8 { font-size: 450%; }\n    :host /deep/ span.w7 { font-size: 400%; }\n    :host /deep/ span.w6 { font-size: 350%; }\n    :host /deep/ span.w5 { font-size: 300%; }\n    :host /deep/ span.w4 { font-size: 250%; }\n    :host /deep/ span.w3 { font-size: 200%; }\n    :host /deep/ span.w2 { font-size: 150%; }\n    :host /deep/ span.w1 { font-size: 100%; }\n\n    /* colors */\n    :host /deep/ a { color: inherit; }\n    :host /deep/ a:hover { color: #0df; }\n    :host /deep/ a:hover { color: #0cf; }\n    :host /deep/ span.w10 { color: #0cf; }\n    :host /deep/ span.w9 { color: #0cf; }\n    :host /deep/ span.w8 { color: #0cf; }\n    :host /deep/ span.w7 { color: #39d; }\n    :host /deep/ span.w6 { color: #90c5f0; }\n    :host /deep/ span.w5 { color: #90a0dd; }\n    :host /deep/ span.w4 { color: #90c5f0; }\n    :host /deep/ span.w3 { color: #a0ddff; }\n    :host /deep/ span.w2 { color: #99ccee; }\n    :host /deep/ span.w1 { color: #aab5f0; }\n\n    /* layout */\n    :host {\n      color: #09f;\n      overflow: hidden;\n      position: relative;\n      display: block;\n    }\n    :host /deep/ span { padding: 0; }\n  "]
                },] },
    ];
    /** @nocollapse */
    TagCloudComponent.ctorParameters = [
        { type: core_1.ElementRef, },
        { type: core_1.Renderer, },
        { type: platform_browser_1.DomSanitizer, },
    ];
    TagCloudComponent.propDecorators = {
        'data': [{ type: core_1.Input },],
        'width': [{ type: core_1.Input },],
        'height': [{ type: core_1.Input },],
        'removeOverflow': [{ type: core_1.Input },],
    };
    return TagCloudComponent;
}());
exports.TagCloudComponent = TagCloudComponent;
//# sourceMappingURL=tag-cloud.component.js.map